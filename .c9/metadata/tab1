{"filter":false,"title":"Immediate (Javascript (browser))","tooltip":"Immediate (Javascript (browser))","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":313,"column":5},"end":{"row":314,"column":0},"action":"insert","lines":["",""]},{"start":{"row":314,"column":0},"end":{"row":315,"column":0},"action":"insert","lines":["",""]}]}]]},"immediate":{"folds":[],"scrolltop":4556,"scrollleft":0,"selection":{"start":{"row":315,"column":0},"end":{"row":315,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":313,"state":"no_regex","mode":"ace/mode/javascript"},"type":"jsbrowser","history":["jPack","/**\n * =========================================================================== *\n * Collection of reusable tools                                                *\n * @author Alexander Mihaylov <lex.mihaylov@gmail.com>                         *\n * =========================================================================== *\n */\n\n/**\n * jpack wrapper\n * @param {window} win\n * @returns {undefined}\n */\n(function(win) {\n    win.jPack = win.jPack || {};\n    \n    /**\n     * Library version\n     */\n    win.jPack.VERSION = '0.1.0';\n\n    /**\n     * Contains additional math methods\n     */\n    win.jPack.calc = {\n        /**\n         * Converts radians to degrees\n         * @param {Number} radians\n         * @returns {Number}\n         */\n        radToDeg: function(radians) {\n            return radians * (180 / Math.PI);\n        },\n\n        /**\n         * Converts degrees to radians\n         * @param {Number} degrees\n         * @returns {Number}\n         */\n        degToRad: function(degrees) {\n            return degrees * (Math.PI / 180);\n        },\n\n        /**\n         * Generates a random number\n         * @param {Number} min\n         * @param {Number} max\n         * @returns {Number}\n         */\n        random: function(min, max) {\n            return Math.random() * (max - min) + min;\n        },\n\n        /**\n         * Rounds a value with precision\n         * @param {Number} num\n         * @param {Number} precision\n         * @returns {Number}\n         */\n        round: function(num, precision) {\n            if (!precision) precision = 0;\n            var p = Math.pow(10, precision);\n            return Math.round(num * p) / p;\n        },\n\n        /**\n         * Floors a value with precision\n         * @param {type} num\n         * @param {type} precision\n         * @returns {Number}\n         */\n        floor: function(num, precision) {\n            if (!precision) precision = 0;\n            var p = Math.pow(10, precision);\n            return Math.floor(num * p) / p;\n        },\n\n        /**\n         * Ceils a value with precision\n         * @param {type} num\n         * @param {type} precision\n         * @returns {Number}\n         */\n        ceil: function(num, precision) {\n            if (!precision) precision = 0;\n            var p = Math.pow(10, precision);\n            return Math.ceil(num * p) / p;\n        },\n\n        /**\n         * calculate percentage value\n         * @param {Number} part\n         * @param {Number} whole\n         * @returns {Number}\n         */\n        percentage: function(part, whole) {\n            return part / whole * 100;\n        },\n\n        /**\n         * Calculates the intersection between to rectangles and returns a new rectangle\n         * containing the dimenssions of the intersected area\n         * @param {Object} rect1\n         * @param {Object} rect2\n         * @returns {Object}\n         */\n        rectIntersect: function(rect1, rect2) {\n            var rx1 = rect1.x,\n                ry1 = rect1.y,\n                rx11 = rx1 + rect1.width,\n                ry11 = ry1 + rect1.height,\n\n                rx2 = rect2.x,\n                ry2 = rect2.y,\n                rx21 = rx2 + rect2.width,\n                ry21 = ry2 + rect2.height;\n\n            var newRect = {\n                x: Math.max(rx2, rx1),\n                y: Math.max(ry2, ry1)\n            };\n\n            newRect.width = Math.min(rx21, rx11) - Math.max(rx2, rx1);\n            newRect.height = Math.min(ry21, ry11) - Math.max(ry2, ry1);\n\n            return newRect;\n        },\n\n        /**\n         * Calculate a point of a cicle\n         * @param {Object} point\n         * @param {Number} radius\n         * @param {Number} angInDeg\n         * @returns {Object}\n         */\n        pointOfCircle: function(point, radius, angInDeg) {\n            return {\n                x: point.x + radius * Math.cos(this.degToRad(angInDeg)),\n                y: point.y + radius * Math.sin(this.degToRad(angInDeg))\n            };\n        },\n\n\n        /**\n         * Calculate a point of an ellipse\n         * @param {Object} point\n         * @param {Number} radiusX\n         * @param {Number} radiusY\n         * @param {Number} angInDeg\n         * @returns {Object}\n         */\n        pointOfEllipse: function(point, radiusX, radiusY, angInDeg) {\n            return {\n                x: point.x + radiusX * Math.cos(this.degToRad(angInDeg)),\n                y: point.y + radiusY * Math.sin(this.degToRad(angInDeg))\n            };\n        },\n\n        /**\n         * Calculates the distance between two points\n         * @param {Object} point1\n         * @param {Object} point2\n         * @returns {Number}\n         */\n        distanceBetweenPoints: function(point1, point2) {\n            return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y, point1.y, 2));\n        },\n\n        /**\n         * Determins if a point is contained inside a rectabgle\n         * @param {type} point\n         * @param {type} rect\n         * @returns {Boolean}\n         */\n        pointInRectangle: function(point, rect) {\n            var rx = rect.x + rect.width;\n            var ry = rect.y + rect.height;\n            return (point.x > rect.x && point.y > rect.y && point.x < rx && point.y < ry);\n        },\n\n        /**\n         * Determins if a point is inside a circle\n         * @param {Object} point\n         * @param {Number} radius\n         * @param {Object} centerPoint\n         * @returns {Boolean}\n         */\n        pointInCircle: function(point, radius, centerPoint) {\n            return (Math.pow(point.x - centerPoint.x, 2) + Math.pow(point.y - centerPoint.y, 2)) < Math.pow(radius, 2);\n        },\n\n        /**\n         * Gets a text mesurements\n         * @param {type} text\n         * @param {type} fontSize\n         * @param {type} fontFamily\n         * @returns {Object}\n         */\n        measureText: function(text, fontSize, fontFamily) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            ctx.fond = fontSize + \" \" + fontFamily;\n            return ctx.measureText(text);\n        }\n    };\n\n    /**\n     * Creates an animation object using requestAnimationFrame or setTimeout\n     * @class jpack.Animation\n     * @constructor\n     */\n    win.jPack.Animation = function(handler) {\n        this.animationFrame = win.requestAnimationFrame ||\n            win.mozRequestAnimationFrame ||\n            win.webkitRequestAnimationFrame ||\n            win.msRequestAnimationFrame ||\n            function(callback) {\n                return win.setTimeout(callback, 1000 / 60);\n            };\n        this.handler = handler;\n        this.animId = null;\n        this.isStopped = false;\n        this.isDestroyed = false;\n        this.isStarted = false;\n    };\n\n    /**\n     * public methods\n     */\n    win.jPack.Animation.prototype = {\n        /**\n         * Start the animation loop\n         * @returns {undefined}\n         */\n        start: function() {\n            var _this = this;\n            _this.isStopped = false;\n            if (!_this.isStarted) {\n                _this.isStarted = true;\n\n                var loopFn = function () {\n                    if (!_this.isDestroyed) {\n                        if (!_this.isStopped) {\n                            _this.handler.apply(_this, arguments);\n                        }\n\n                        _this.animationFrame.call(win, loopFn);\n                    }\n                };\n\n                _this.animationFrame.call(win, loopFn);\n\n            }\n        },\n\n        /**\n         * Stop/Pause animation loop\n         * @returns {undefined}\n         */\n        stop: function() {\n            this.isStopped = true;\n        },\n\n        /**\n         * Destroy the animation loop\n         * @returns {undefined}\n         */\n        destroy: function() {\n            this.isDestroyed = true;\n            this.isStarted = false;\n        }\n    };\n\n    /**\n     * Creates an async task using requestAnimationFrame or setTimeout\n     * @param {function} handler\n     * @class jpackAsync\n     * @constructor\n     */\n    win.jPack.Async = function(handler) {\n        this.asyncTask = win.requestAnimationFrame ||\n            win.mozRequestAnimationFrame ||\n            win.webkitRequestAnimationFrame ||\n            win.msRequestAnimationFrame ||\n            function(callback) {\n                return win.setTimeout(callback, 0);\n            };\n        this.handler = handler;\n    };\n\n    /**\n     * public methods\n     */\n    win.jPack.Async.prototype = {\n        /**\n         * Execute a task asyncroniously\n         * @returns {undefined}\n         */\n        start: function() {\n            var _this = this;\n            _this.asyncTask.call(win, function() {\n                _this.handler.apply(_this, arguments);\n            });\n        }\n    };\n})(window);","window.jPack.calc","window.jPack"],"pos":-1},"timestamp":1420647243133,"hash":"c00354c37736af1b0c72eb1a1174eb5edd2ef2c2"}